<!--
CineCam Pro - A fully functional, single-file HTML5 web app for mobile and desktop.
Features: Live video filters, manual camera controls, cinematic presets, photo/video capture, and more.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta tags for character set, viewport, and compatibility -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CineCam Pro</title>

    <!-- Google Fonts: Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <!-- Tweakpane Library for UI controls -->
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.0/dist/tweakpane.min.js"></script>
    
    <!-- glfx.js for WebGL-based filter effects -->
    <script src="https://cdn.jsdelivr.net/npm/glfx@1.1.2/glfx.min.js"></script>

    <style>
        /* --- CSS Variables and Theming --- */
        :root {
            --background-color: #1a1a1a;
            --text-color: #f0f0f0;
            --primary-color: #00aaff;
            --surface-color: #2a2a2a;
            --border-color: #444;
        }

        body.light-mode {
            --background-color: #f0f0f0;
            --text-color: #1a1a1a;
            --primary-color: #0077cc;
            --surface-color: #ffffff;
            --border-color: #ccc;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        h1 {
            display: none; /* Hide title on app screen for more space */
        }

        /* --- App Layout (Mobile First) --- */
        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: black;
        }

        #video-preview, #overlay-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            object-fit: contain; /* 'contain' is better for seeing the whole frame */
        }
        
        #overlay-canvas {
            z-index: 10;
        }

        #histogram-canvas {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 256px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            z-index: 30; /* Above other overlays */
        }

        #video-source {
            display: none; /* The raw video source is never shown to the user */
        }

        #controls-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 26, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow-y: auto;
            z-index: 20;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
        }

        #controls-container.visible {
            transform: translateX(0);
        }
        
        /* --- UI Overlay Elements --- */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to video */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .top-bar, .bottom-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: all; /* Make elements in bars clickable */
        }

        .top-bar {
            justify-content: flex-end; /* Push controls button to the right */
        }

        #capture-container {
            display: flex;
            gap: 15px;
        }

        #audio-visualizer {
            width: 150px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }

        #audio-level {
            width: 0%;
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 4px;
            transition: width 0.05s linear;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #controls-toggle-button {
            background-color: rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }

        button:hover {
            background-color: #0088cc;
        }

        /* --- Desktop Layout --- */
        @media (min-width: 768px) {
            h1 {
                display: block; /* Show title on desktop */
            }
            #app-container {
                width: 100%;
                max-width: 1200px;
                height: auto;
                aspect-ratio: 16 / 9;
                margin: 20px;
                border-radius: 12px;
                overflow: hidden;
            }
            #controls-container {
                transform: translateX(0);
                position: absolute;
                top: 0;
                right: 0;
                left: auto;
                width: 300px;
                height: 100%;
                box-shadow: -5px 0 15px rgba(0,0,0,0.2);
            }
            #controls-toggle-button {
                display: none; /* Hide toggle button on desktop */
            }
            .ui-overlay {
                padding: 30px;
            }
             #capture-container {
                position: absolute;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
            }
            .bottom-bar {
                justify-content: center;
            }
            #audio-visualizer, .bottom-bar > div:last-child {
                display: none; /* Hide spacer and visualizer on desktop for a cleaner look */
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- The hidden video element that receives the raw camera feed -->
        <video id="video-source" autoplay playsinline></video>
        
        <!-- The WebGL canvas where the video is rendered with effects -->
        <canvas id="video-preview"></canvas>
        <!-- The 2D canvas for drawing UI overlays like grids and guides -->
        <canvas id="overlay-canvas"></canvas>
        <!-- The canvas for displaying the real-time histogram -->
        <canvas id="histogram-canvas"></canvas>

        <!-- Container for Tweakpane UI controls, slides in from the side -->
        <div id="controls-container"></div>

        <!-- Overlay for UI elements that sit on top of the video -->
        <div class="ui-overlay">
            <div class="top-bar">
                <button id="controls-toggle-button">Controls</button>
            </div>
            <div class="bottom-bar">
                 <div id="audio-visualizer">
                    <div id="audio-level"></div>
                </div>
                <div id="capture-container">
                    <button id="capture-photo">Photo</button>
                    <button id="record-video">Record</button>
                </div>
                <!-- Empty div for spacing -->
                <div style="width: 150px;"></div>
            </div>
        </div>
    </div>
    
    <!-- Container for generated download links, appears below the main app -->
    <div id="download-links"></div>

    <script>
        // --- DOM Elements ---
        const video = document.getElementById('video-source');
        const glCanvas = document.getElementById('video-preview');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const histogramCanvas = document.getElementById('histogram-canvas');
        const histogramCtx = histogramCanvas.getContext('2d');
        const controlsContainer = document.getElementById('controls-container');
        const controlsToggleButton = document.getElementById('controls-toggle-button');

        // --- State ---
        let stream;
        let audioContext, analyser, dataArray;
        let pane, settingsFolder; // Make pane and settings folder globally accessible
        let lastRenderTime = 0; // For frame rate simulation
        let webgl, texture; // For WebGL rendering

        const PRESETS = {
            'None': { brightness: 0, contrast: 0, saturate: 0, sepia: 0, hue: 0 },
            'Teal & Orange': { brightness: 0.05, contrast: 0.1, saturate: 0.2, sepia: 0.1, hue: -0.05 },
            'Vintage Film': { brightness: 0.1, contrast: -0.05, saturate: -0.15, sepia: 0.3, hue: 0 },
            'Noir': { brightness: 0.1, contrast: 0.2, saturate: -1, sepia: 0, hue: 0 },
            'Lomograph': { brightness: 0, contrast: 0.15, saturate: 0.15, sepia: 0.05, hue: 0.02 },
        };
        const RESOLUTIONS = {
            '720p': { width: 1280, height: 720 },
            '1080p': { width: 1920, height: 1080 },
            '4K': { width: 3840, height: 2160 },
        };
        const PARAMS = { 
            zoom: 1,
            deviceId: 'default',
            // --- WebGL Shader Params ---
            brightness: 0,
            contrast: 0,
            saturate: 0,
            hue: 0,
            sepia: 0,
            sharpness: 0,
            exposure: 0,
            temperature: 6500, // In Kelvin, 6500 is neutral
            // --- Overlay & App Params ---
            showCropBars: false,
            showRuleOfThirds: true,
            showHistogram: false,
            mirror: false,
            darkMode: true,
            resolution: '1080p',
            frameRate: 'Native',
        };

        // --- UI Initialization ---
        /**
         * Sets up the Tweakpane control panel with all the sliders, toggles, and buttons.
         */
        function setupControls() {
            pane = new Tweakpane.Pane({
                container: document.getElementById('controls-container'),
                title: 'CineCam Pro Controls',
            });

            // --- Cinematic Presets ---
            const presetFolder = pane.addFolder({ title: 'Cinematic Presets' });
            presetFolder.addInput({ preset: 'None' }, 'preset', {
                options: Object.keys(PRESETS).map(name => ({ text: name, value: name })),
            }).on('change', (ev) => {
                const preset = PRESETS[ev.value];
                if (preset) {
                    // Update the PARAMS object with the values from the selected preset
                    Object.keys(preset).forEach(key => {
                        if (key in PARAMS) PARAMS[key] = preset[key];
                    });
                    // Refresh the Tweakpane UI to show the new values
                    pane.refresh();
                }
            });

            // --- Manual Shader Controls ---
            const manualFolder = pane.addFolder({ title: 'Manual Controls', expanded: true });
            manualFolder.addInput(PARAMS, 'exposure', { min: -1, max: 1, step: 0.05, label: 'Exposure' });
            manualFolder.addInput(PARAMS, 'contrast', { min: -1, max: 1, step: 0.05, label: 'Contrast' });
            manualFolder.addInput(PARAMS, 'saturate', { min: -1, max: 1, step: 0.05, label: 'Saturation' });
            manualFolder.addInput(PARAMS, 'temperature', { min: 2000, max: 10000, step: 100, label: 'Temp (K)' });
            manualFolder.addInput(PARAMS, 'sharpness', { min: 0, max: 5, step: 0.1, label: 'Sharpness' });

            // Folder for guides and overlays
            const overlayFolder = pane.addFolder({ title: 'Visual Guides' });
            overlayFolder.addInput(PARAMS, 'showCropBars', { label: 'Cinematic Bars (2.35:1)' });
            overlayFolder.addInput(PARAMS, 'showRuleOfThirds', { label: 'Rule of Thirds Grid' });
            overlayFolder.addInput(PARAMS, 'showHistogram', { label: 'Histogram' });
            overlayFolder.addInput(PARAMS, 'mirror', { label: 'Mirror Video' });

            // Folder for app settings like resolution and theme
            settingsFolder = pane.addFolder({ title: 'Settings' });
            settingsFolder.addInput(PARAMS, 'darkMode', { label: 'Dark Mode' }).on('change', (ev) => {
                document.body.classList.toggle('light-mode', !ev.value);
            });

            settingsFolder.addInput(PARAMS, 'resolution', {
                label: 'Resolution',
                options: Object.keys(RESOLUTIONS).map(r => ({ text: r, value: r })),
            }).on('change', (ev) => {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                setupCamera(RESOLUTIONS[ev.value]);
            });

            settingsFolder.addInput(PARAMS, 'frameRate', {
                label: 'Frame Rate',
                options: [ { text: 'Native', value: 'Native' }, { text: '30 fps', value: '30' }, { text: '24 fps', value: '24' } ]
            });
        }

        /** Populates the camera selection dropdown once permissions are granted. */
        async function populateCameraControl() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                if (videoDevices.length > 1 && settingsFolder && !settingsFolder.cameraControlAdded) {
                    const cameraOptions = videoDevices.map(device => ({
                        text: device.label || `Camera ${videoDevices.indexOf(device) + 1}`,
                        value: device.deviceId
                    }));
                    cameraOptions.unshift({ text: 'Default', value: 'default' });
                    const cameraControl = settingsFolder.addInput(PARAMS, 'deviceId', { label: 'Camera', options: cameraOptions });
                    cameraControl.on('change', () => setupCamera(RESOLUTIONS[PARAMS.resolution]));
                    settingsFolder.cameraControlAdded = true;
                }
            } catch (err) {
                console.warn("Could not populate camera list.", err);
            }
        }

        /** Probes the camera for native hardware controls and adds them to the UI if supported. */
        function setupNativeControls() {
            const track = stream.getVideoTracks()[0];
            if (!track) return;

            const capabilities = track.getCapabilities();

            // Only create the folder if at least one native control is supported
            let nativeFolder;
            const addNativeFolder = () => {
                if (!nativeFolder) {
                    nativeFolder = pane.addFolder({ title: 'Native Controls', expanded: false });
                }
            };

            // --- ISO Control ---
            if (capabilities.iso) {
                addNativeFolder();
                nativeFolder.addInput(track.getSettings(), 'iso', {
                    min: capabilities.iso.min,
                    max: capabilities.iso.max,
                    step: capabilities.iso.step || 1,
                    label: 'ISO'
                }).on('change', (ev) => track.applyConstraints({ advanced: [{ iso: ev.value }] }));
            }

            // --- Exposure Compensation Control ---
            if (capabilities.exposureCompensation) {
                addNativeFolder();
                nativeFolder.addInput(track.getSettings(), 'exposureCompensation', {
                    min: capabilities.exposureCompensation.min,
                    max: capabilities.exposureCompensation.max,
                    step: capabilities.exposureCompensation.step || 0.1,
                    label: 'EV Comp'
                }).on('change', (ev) => track.applyConstraints({ advanced: [{ exposureCompensation: ev.value }] }));
            }

            // --- Focus Control ---
            if (capabilities.focusMode && capabilities.focusMode.includes('manual')) {
                 addNativeFolder();
                 // Focus distance
                 if (capabilities.focusDistance) {
                    nativeFolder.addInput(track.getSettings(), 'focusDistance', {
                        min: capabilities.focusDistance.min,
                        max: capabilities.focusDistance.max,
                        step: capabilities.focusDistance.step || 0.01,
                        label: 'Focus'
                    }).on('change', async (ev) => {
                        await track.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: ev.value }] });
                    });
                 }
            }
        }

        /** Initializes the camera stream. */
        async function setupCamera(constraints = RESOLUTIONS['1080p']) {
            if (stream) stream.getTracks().forEach(track => track.stop());
            try {
                const videoConstraints = {
                    width: { ideal: constraints.width },
                    height: { ideal: constraints.height },
                };
                if (PARAMS.deviceId && PARAMS.deviceId !== 'default') {
                    videoConstraints.deviceId = { exact: PARAMS.deviceId };
                } else {
                    videoConstraints.facingMode = 'environment';
                }
                stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: true });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    const streamSettings = stream.getVideoTracks()[0].getSettings();
                    // Set canvas sizes
                    glCanvas.width = overlayCanvas.width = streamSettings.width;
                    glCanvas.height = overlayCanvas.height = streamSettings.height;

                    if (!webgl) { // Initialize WebGL canvas on first run
                        webgl = fx.canvas();
                        texture = webgl.texture(video);
                        webgl.replace(glCanvas);
                    }

                    if (settingsFolder && !settingsFolder.cameraControlAdded) {
                        populateCameraControl();
                        // Also set up native controls on the first valid stream
                        setupNativeControls();
                    }
                    setupAudioVisualizer();
                    lastRenderTime = 0;
                    requestAnimationFrame(renderFrame);
                };
            } catch (err) {
                console.error("Camera Error:", err);
                alert(`Could not access camera. Error: ${err.message}`);
            }
        }

        // --- Overlay Drawing Functions ---
        function drawRuleOfThirdsGrid() {
            const w = overlayCanvas.width, h = overlayCanvas.height;
            overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            overlayCtx.lineWidth = 1;
            overlayCtx.setLineDash([5, 3]);
            overlayCtx.beginPath();
            overlayCtx.moveTo(w / 3, 0); overlayCtx.lineTo(w / 3, h);
            overlayCtx.moveTo(2 * w / 3, 0); overlayCtx.lineTo(2 * w / 3, h);
            overlayCtx.moveTo(0, h / 3); overlayCtx.lineTo(w, h / 3);
            overlayCtx.moveTo(0, 2 * h / 3); overlayCtx.lineTo(w, 2 * h / 3);
            overlayCtx.stroke();
            overlayCtx.setLineDash([]);
        }

        function drawCropBars() {
            const w = overlayCanvas.width, h = overlayCanvas.height;
            const targetHeight = w / 2.35;
            const barHeight = (h - targetHeight) / 2;
            if (barHeight > 0) {
                overlayCtx.fillStyle = 'black';
                overlayCtx.fillRect(0, 0, w, barHeight);
                overlayCtx.fillRect(0, h - barHeight, w, barHeight);
            }
        }

        /**
         * Converts a color temperature in Kelvin to an RGB multiplier.
         * This is a simplified approximation.
         * @param {number} kelvin - The temperature in Kelvin.
         * @returns {Array<number>} An array of [r, g, b] multipliers.
         */
        function kelvinToRGB(kelvin) {
            kelvin = kelvin / 100;
            let r, g, b;

            // Red component
            if (kelvin <= 66) {
                r = 255;
            } else {
                r = kelvin - 60;
                r = 329.698727446 * Math.pow(r, -0.1332047592);
            }

            // Green component
            if (kelvin <= 66) {
                g = kelvin;
                g = 99.4708025861 * Math.log(g) - 161.1195681661;
            } else {
                g = kelvin - 60;
                g = 288.1221695283 * Math.pow(g, -0.0755148492);
            }

            // Blue component
            if (kelvin >= 66) {
                b = 255;
            } else {
                if (kelvin <= 19) {
                    b = 0;
                } else {
                    b = kelvin - 10;
                    b = 138.5177312231 * Math.log(b) - 305.0447927307;
                }
            }

            return [
                Math.max(0, Math.min(255, r)) / 255,
                Math.max(0, Math.min(255, g)) / 255,
                Math.max(0, Math.min(255, b)) / 255
            ];
        }

        /** The main rendering loop. */
        function renderFrame(timestamp) {
            requestAnimationFrame(renderFrame);

            if (PARAMS.frameRate !== 'Native') {
                const targetInterval = 1000 / Number(PARAMS.frameRate);
                const elapsed = timestamp - lastRenderTime;
                if (elapsed < targetInterval) return;
                lastRenderTime = timestamp - (elapsed % targetInterval);
            }

            // --- WebGL Render Pass ---
            if (webgl && texture && video.readyState === video.HAVE_ENOUGH_DATA) {
                texture.loadContentsOf(video);
                let node = webgl.draw(texture);

                // Apply filters if their values are not neutral
                if (PARAMS.exposure !== 0 || PARAMS.contrast !== 0) {
                    node = node.brightnessContrast(PARAMS.exposure, PARAMS.contrast);
                }
                if (PARAMS.hue !== 0 || PARAMS.saturate !== 0) {
                    node = node.hueSaturation(PARAMS.hue, PARAMS.saturate);
                }
                if (PARAMS.sharpness > 0) {
                    node = node.unsharpMask(2, PARAMS.sharpness);
                }
                if (PARAMS.temperature !== 6500) {
                    const rgb = kelvinToRGB(PARAMS.temperature);
                    // Adjust curves based on temperature. This is a creative interpretation.
                    // Warmer temps boost red/green, cooler temps boost blue.
                    node = node.curves(
                        [[0,0], [rgb[0], rgb[0]], [1,1]], // Red
                        [[0,0], [rgb[1], rgb[1]], [1,1]], // Green
                        [[0,0], [rgb[2], rgb[2]], [1,1]]  // Blue
                    );
                }
                if (PARAMS.mirror) {
                    node = node.flip('x');
                }

                node.update(); // Final render to canvas
            }

            // --- 2D Overlay Render Pass ---
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            if (PARAMS.showRuleOfThirds) drawRuleOfThirdsGrid();
            if (PARAMS.showCropBars) drawCropBars();
            
            // --- UI Update ---
            if (PARAMS.showHistogram) {
                updateHistogram();
                histogramCanvas.style.display = 'block';
            } else {
                histogramCanvas.style.display = 'none';
            }
            updateAudioVisualizer();
        }

        /** Reads the WebGL canvas and draws a real-time histogram. */
        function updateHistogram() {
            const w = histogramCanvas.width;
            const h = histogramCanvas.height;
            const gl = webgl.gl;

            // Read pixels from the WebGL canvas
            const pixels = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
            gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            const bins = new Uint32Array(256).fill(0);
            let maxBin = 0;

            // Calculate luminosity and populate bins
            for (let i = 0; i < pixels.length; i += 4) {
                // Using standard luminosity calculation
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const luminosity = Math.round(0.21 * r + 0.72 * g + 0.07 * b);
                bins[luminosity]++;
            }

            // Find the max bin value for scaling
            for (let i = 0; i < 256; i++) {
                if (bins[i] > maxBin) {
                    maxBin = bins[i];
                }
            }

            // Draw the histogram
            histogramCtx.clearRect(0, 0, w, h);
            histogramCtx.fillStyle = 'rgba(255, 255, 255, 0.75)';
            for (let i = 0; i < 256; i++) {
                const value = (bins[i] / maxBin) * h;
                histogramCtx.fillRect(i * (w / 256), h - value, (w / 256), value);
            }
        }

        // --- Audio Analysis ---
        /** Sets up the Web Audio API to analyze microphone input. */
        function setupAudioVisualizer() {
            if (!stream.getAudioTracks().length) {
                console.warn("Audio track not available, visualizer disabled.");
                return;
            }
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser); // Connect the microphone source to the analyzer

            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
        }

        /** Analyzes audio data and updates the visualizer bar. */
        function updateAudioVisualizer() {
            if (!analyser) return;

            analyser.getByteFrequencyData(dataArray); // Get frequency data
            
            let sum = 0;
            for (const amplitude of dataArray) {
                sum += amplitude;
            }
            const average = sum / dataArray.length;
            // Normalize and scale the volume for better visualization
            const volumePercent = (average / 255) * 150; 
            
            const audioLevelEl = document.getElementById('audio-level');
            if (audioLevelEl) {
                audioLevelEl.style.width = `${Math.min(100, volumePercent)}%`;
            }
        }

        // --- Media Capture State ---
        let mediaRecorder; // The MediaRecorder instance
        let recordedChunks = []; // Array to store recorded video chunks
        let isRecording = false; // Flag to track recording status

        // --- Capture & Recording Setup ---
        /** Sets up event listeners for photo and video capture buttons. */
        function setupMediaButtons() {
            const photoButton = document.getElementById('capture-photo');
            const recordButton = document.getElementById('record-video');
            const downloadLinksContainer = document.getElementById('download-links');

            // Photo Capture
            photoButton.addEventListener('click', () => {
                // Create a temporary canvas to composite the WebGL and overlay canvases
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const w = webgl.canvas.width;
                const h = webgl.canvas.height;
                tempCanvas.width = w;
                tempCanvas.height = h;

                // 1. Draw the WebGL canvas content
                tempCtx.drawImage(webgl.canvas, 0, 0, w, h);

                // 2. Draw the 2D overlay canvas on top
                tempCtx.drawImage(overlayCanvas, 0, 0, w, h);

                // 3. Get the final image data
                const dataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                
                // Create a temporary link to trigger the download
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = `CineCamPro_Capture_${Date.now()}.jpg`;
                link.click();
            });

            // Video Recording
            recordButton.addEventListener('click', () => {
                if (isRecording) {
                    // --- Stop Recording ---
                    mediaRecorder.stop();
                    recordButton.textContent = 'Start Recording';
                    recordButton.style.backgroundColor = ''; // Revert to default color
                    isRecording = false;
                } else {
                    // --- Start Recording ---
                    startRecording();
                    recordButton.textContent = 'Stop Recording';
                    recordButton.style.backgroundColor = '#ff4136'; // Use red to indicate recording
                    isRecording = true;
                }
            });

            /** Initializes and starts the video recording process. */
            function startRecording() {
                recordedChunks = [];
                // Get a video stream from the canvas (includes all visual effects)
                const canvasStream = canvas.captureStream(30); // Record at 30 FPS
                
                // Get the audio track from the original microphone stream
                const audioTracks = stream.getAudioTracks();
                
                // Combine the canvas video and microphone audio into one stream
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...audioTracks
                ]);

                // Create and configure the MediaRecorder
                mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: 'video/webm; codecs=vp9,opus' // Use a modern, high-quality codec
                });

                // Event handler for when data is available
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                // Event handler for when recording is stopped
                mediaRecorder.onstop = () => {
                    // Combine all recorded chunks into a single Blob
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    // Create a download link for the recorded video
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `CineCamPro_Recording_${Date.now()}.webm`;
                    link.textContent = `Download Video (${(blob.size / 1024 / 1024).toFixed(2)} MB)`;
                    link.style.display = 'block';
                    link.style.margin = '10px';
                    downloadLinksContainer.appendChild(link);
                };
                
                mediaRecorder.start(); // Start recording
            }
        }

        // --- Application Entry Point ---
        /**
         * Main initializer that runs when the DOM is fully loaded.
         */
        document.addEventListener('DOMContentLoaded', () => {
            // Set the initial theme based on the PARAMS default
            document.body.classList.toggle('light-mode', !PARAMS.darkMode);
            
            // Set up the UI controls panel
            setupControls();

            // Set up media capture buttons
            setupMediaButtons();

            // Set up the mobile controls toggle button
            controlsToggleButton.addEventListener('click', () => {
                controlsContainer.classList.toggle('visible');
            });
            
            // Hide controls panel when clicking outside of it on mobile
            canvas.addEventListener('click', () => {
                if (controlsContainer.classList.contains('visible')) {
                    controlsContainer.classList.remove('visible');
                }
            });

            // Initialize the camera
            setupCamera(RESOLUTIONS[PARAMS.resolution]);
        });
    </script>

</body>
</html>
